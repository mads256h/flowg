#include <math.fg>;

number _filamentDiameter = 0;
number _nozzleDiameter = 0;
number _layerHeight = 0;
point _currentPosition = [0,0,0];
// Default for ultimaker 2
//number _filamentDiameter = 2.85;
//number _nozzleDiameter = 0.4;
//number _layerHeight = 0.1;
//point _currentPosition = [0,0,0];

number _calculateFilamentVolumeNeeded(number length){
    number filamentNeeded = length * _nozzleDiameter * _layerHeight;
    number filamentArea = (_filamentDiameter / 2)^2 * pi;
    if (!(filamentArea == 0)){
        number filamentMM = filamentNeeded / filamentArea;
        return filamentMM;
    }
    else{
        return 0;
    };
};

point line(point endpoint){
    number dist = distance(_currentPosition, endpoint);
    number filamentMm = _calculateFilamentVolumeNeeded(dist);

    gcode gcodeLine(point endpoint, number filament){
    	G1 E[filament] X[endpoint.x] Y[endpoint.y] Z[endpoint.z]
    };
    gcodeLine(endpoint, filamentMm);
    _currentPosition = endpoint;
    return _currentPosition;
};

point _arc(point center, point wantedEndpoint, bool is_cw){
    number i = center.x - _currentPosition.x;
    number j = center.y - _currentPosition.y;
    // We calculate the point where the circle ends
    point vector = wantedEndpoint - center;
    point normalizedVector = [vector.x / sqrt(vector.x^2 + vector.y^2),vector.y / sqrt(vector.x^2 + vector.y^2),0];
    number radius = sqrt((center.x - _currentPosition.x)^2 + (center.y - _currentPosition.y)^2);
    point realEndpoint = (normalizedVector * radius) + center;
    // We define the Gcode helper functions

    gcode gcodeCArc(point endpoint, number i, number j, number e){
        G2 E[e] X[endpoint.x] Y[endpoint.y] I[i] J[j]
    };

    gcode gcodeCWArc(point endpoint, number i, number j, number e){
        G3 E[e] X[endpoint.x] Y[endpoint.y] I[i] J[j]
    };

    // We calculate the other sides and the C angle (in radians) with trigonometry
    number c = sqrt((realEndpoint.x - _currentPosition.x)^2 + (realEndpoint.y - _currentPosition.y)^2);
    number cosC = (2 *radius^2 - c^2) / (2 * radius^2);
    number C = arccos(cosC);
    //We calculate the circumference and multiply it by the percentage of the circle that is filled out
    number circumference = radius * 2 * pi;

    //We now know the filament needed for each of the filled edges and now we need to calculate whether clockwise or
    //counter clockwise has the biggest side
    number smallestFilledCircumference = circumference * (C / (2 * pi));
    number biggestFilledCircumference = circumference - smallestFilledCircumference;
    number biggestFilamentMM = _calculateFilamentVolumeNeeded(biggestFilledCircumference);
    number smallestFilamentMM = _calculateFilamentVolumeNeeded(smallestFilledCircumference);

    // We figure out the function between the current position and center of circle
    number a = 0;
    number b = 0;

    bool clockwiseIsSmallest = false;
    bool cClockwiseIsSmallest = false;

    //If current position.x == center.x both lines will be the same length
    if (_currentPosition.x > center.x){
        a = (_currentPosition.x - center.x) / (_currentPosition.y - center.y);
        b = _currentPosition.y - _currentPosition.x * a;
    }else{
        a = (center.x - _currentPosition.x) / (center.y - _currentPosition.y);
        b = center.y - center.x * a;
    };
    if (a * wantedEndpoint.x + b < wantedEndpoint.y){
        clockwiseIsSmallest = true;
    } else{
        cClockwiseIsSmallest = true;
    };

    // We call the correct gcode function with the right parameters
    if (is_cw) {
        if (clockwiseIsSmallest){
            gcodeCArc(realEndpoint, i, j, smallestFilamentMM);
        } else {
            gcodeCArc(realEndpoint, i, j, biggestFilamentMM);
        };
        } else {
        if (cClockwiseIsSmallest){
            gcodeCWArc(realEndpoint, i, j, smallestFilamentMM);
        } else {
            gcodeCWArc(realEndpoint, i, j, biggestFilamentMM);
        };
    };
    _currentPosition = realEndpoint;
    return _currentPosition;
};

point arc(point center, point wantedEndpoint){
    return _arc(center, wantedEndpoint, true);
};

point cArc(point center, point wantedEndpoint){
    return _arc(center, wantedEndpoint, false);
};

point move(point endpoint){
    gcode gcodeMove(point endpoint){
        G0 X[endpoint.x] Y[endpoint.y] Z[endpoint.z]
    };
    gcodeMove(endpoint);
    _currentPosition = endpoint;
    return _currentPosition;
};


gcode setup(number bedTemperature, number hotendTemperature){
    M140 S[bedTemperature]
    M104 S[hotendTemperature]
    M190 S[bedTemperature]
    M109 S[hotendTemperature]
    M82
    G21
    G90
    G28 X0 Y0 Z0
    G1 X15 Y0 F4000
    G1 Z15.0 F9000
    G92 E0
    G1 Y50 F9000
    G92 E0
    G1 F1000 X0 Y0
    M106 S255
};

gcode cleanup(){
    M140 S0
    M104 S0
    G91
    G1 E-1 F300
    G1 Z+0.5 E-5 X-20 Y-20 F9000
    G28 X0 Y0
};

void setupParameters(number filamentDiameter, number nozzleDiameter, number layerHeight){
    _filamentDiameter = filamentDiameter;
    _nozzleDiameter = nozzleDiameter;
    _layerHeight = layerHeight;
};

// Minor G-code functions
gcode turnOnFan(number spindleSpeed){
    M106 S[spindleSpeed]
};

gcode turnOffFan(number spindleSpeed){
    M107
};

gcode setBedTemperature(number temperature){
    M140 S[temperature]
};

gcode waitBedTemperature(number temperature){
    M190 S[temperature]
};

gcode setHotendTemperature(number temperature){
    M104 S[temperature]
};

gcode waitHotendTemperature(number temperature){
    M109 S[temperature]
};
