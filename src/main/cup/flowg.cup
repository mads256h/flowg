package org.flowsoft.flowg;

import java.util.ArrayList;
import java_cup.runtime.*;
import org.flowsoft.flowg.nodes.*;

terminal INVALID;

terminal TypeNode TYPE;

terminal IdentifierNode IDENTIFIER;

terminal NumberLiteralNode NUMBER_LITERAL;
terminal BooleanLiteralNode BOOLEAN_LITERAL;

terminal MOVE;

// ()
terminal L_PAREN;
terminal R_PAREN;

// {}
terminal L_BRACKET;
terminal R_BRACKET;

// []
terminal L_SQUARE_BRACKET;
terminal R_SQUARE_BRACKET;

terminal ASSIGNMENT;
terminal SEMICOLON;
terminal COMMA;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIVIDE;

non terminal StatementListNode program;
non terminal StatementListNode stmt_list;
non terminal ArrayList<StatementNode> stmt_list_impl;
non terminal StatementNode stmt;
non terminal DeclarationNode decl;
non terminal MoveNode move;
non terminal ActualParameterListNode a_param_list;
non terminal ArrayList<ExpressionNode> a_param_list_impl;
non terminal FormalParameterListNode f_param_list;
non terminal ArrayList<FormalParameterNode> f_param_list_impl;
non terminal FormalParameterNode f_param;
non terminal ExpressionNode expr;
non terminal PointNode point;
non terminal FunctionDefinitionNode func_def;

precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;

start with program;

program ::= stmt_list:l
            {: RESULT = l; :};

stmt_list ::= stmt_list_impl:l
            {: RESULT = new StatementListNode(l); :};

stmt_list_impl ::= stmt_list_impl:l stmt:s SEMICOLON
            {: l.add(s); RESULT = l; :}
            |
            stmt:s SEMICOLON
            {: var list = new ArrayList<StatementNode>(); list.add(s); RESULT = list; :};

stmt ::=decl:d
        {: RESULT = d; :}
        |
        move:m
        {: RESULT = m; :}
        |
        func_def:d
        {: RESULT = d; :};

decl ::= TYPE:t IDENTIFIER:i ASSIGNMENT expr:e
        {: RESULT = new DeclarationNode(t, i, e); :};

move ::= MOVE L_PAREN a_param_list:p R_PAREN
        {: RESULT = new MoveNode(p); :};

a_param_list ::= a_param_list_impl:l
        {: RESULT = new ActualParameterListNode(l); :};

a_param_list_impl ::= a_param_list_impl:l COMMA expr:e
        {: l.add(e); RESULT = l; :}
        |
        expr:e
        {: var l = new ArrayList<ExpressionNode>(); l.add(e); RESULT = l; :};

f_param_list ::= f_param_list_impl:l
        {: RESULT = new FormalParameterListNode(l); :};


f_param_list_impl ::= f_param_list_impl:l COMMA f_param:p
        {: l.add(p); RESULT = l; :}
        |
        f_param:p
        {: var l = new ArrayList<FormalParameterNode>(); l.add(p); RESULT = l; :};

f_param ::= TYPE:t IDENTIFIER:i
        {: RESULT = new FormalParameterNode(t, i); :};

expr ::= NUMBER_LITERAL:n
        {: RESULT = n; :}
        | BOOLEAN_LITERAL:b
        {: RESULT = b; :}
        | point:p
        {: RESULT = p; :}
        | expr:e1 PLUS expr:e2
        {: RESULT = new PlusExpressionNode(e1, e2); :}
        | expr:e1 MINUS expr:e2
        {: RESULT = new MinusExpressionNode(e1, e2); :}
        | expr:e1 TIMES expr:e2
        {: RESULT = new TimesExpressionNode(e1, e2); :}
        | expr:e1 DIVIDE expr:e2
        {: RESULT = new DivideExpressionNode(e1, e2); :}
        | IDENTIFIER:i
        {: RESULT = new IdentifierExpressionNode(i); :}
        ;

func_def ::= TYPE:t IDENTIFIER:i L_PAREN f_param_list:p R_PAREN L_BRACKET stmt_list:l R_BRACKET
        {: RESULT = new FunctionDefinitionNode(t, i, p, l); :};

point ::= L_SQUARE_BRACKET expr:e1 COMMA expr:e2 COMMA expr:e3 R_SQUARE_BRACKET
        {: RESULT = new PointNode(e1, e2, e3); :};
